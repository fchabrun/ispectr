exactly_1_ref_trace_is_present <- all(aaid_subset$n_ref == 1)
at_least_1_short_comment <- any(nchar(aaid_subset$comment_1) >= 3)
at_least_1_long_comment <- any(nchar(aaid_subset$comment_long) >= 3)
# extract mandatory curves
elp_deciphered <- decipherCurve_v2024_2(aaid_subset[aaid_subset$analysis_sequence == "ELP", ])
g_deciphered <- decipherCurve_v2024_2(aaid_subset[aaid_subset$analysis_sequence == "IgG", ])
a_deciphered <- decipherCurve_v2024_2(aaid_subset[aaid_subset$analysis_sequence == "IgA", ])
m_deciphered <- decipherCurve_v2024_2(aaid_subset[aaid_subset$analysis_sequence == "IgM", ])
k_deciphered <- decipherCurve_v2024_2(aaid_subset[aaid_subset$analysis_sequence == "K", ])
l_deciphered <- decipherCurve_v2024_2(aaid_subset[aaid_subset$analysis_sequence == "L", ])
# extract accessory traces
ref_deciphered <- NULL
if (exactly_1_ref_trace_is_present) {
if (nchar(aaid_subset[aaid_subset$analysis_sequence == "Ref", ]$raw_curve) == 1200) {  # check the trace seems legit
ref_deciphered <- decipherCurve_v2024_2(aaid_subset[aaid_subset$analysis_sequence == "Ref", ])
} else {
exactly_1_ref_trace_is_present <- F
}
}
spe_deciphered <- NULL
if (exactly_1_spe_trace_is_present) {
if (nchar(aaid_subset[aaid_subset$program == "J", ]$raw_curve) == 1200) {  # check the trace seems legit
spe_deciphered <- decipherCurve_v2024_2(aaid_subset[aaid_subset$program == "J", ])
} else {
exactly_1_spe_trace_is_present <- F
}
}
# post-process traces
elp_trace <- postprocess_trace(elp_deciphered)
g_trace <- postprocess_trace(g_deciphered)
a_trace <- postprocess_trace(a_deciphered)
m_trace <- postprocess_trace(m_deciphered)
k_trace <- postprocess_trace(k_deciphered)
l_trace <- postprocess_trace(l_deciphered)
if (exactly_1_ref_trace_is_present) {
ref_trace <- postprocess_trace(ref_deciphered)
} else {
ref_trace <- NULL
}
spe_trace <- NULL
spe_fractions <- NULL
spe_peak_data <- NULL
if (exactly_1_spe_trace_is_present) {
# spe_trace <- postprocess_trace(spe_deciphered)
# store spep trace
spe_trace <- spe_deciphered$curve / max(spe_deciphered$curve)
if ((length(spe_deciphered$fractions_coords) >= 5) & (length(spe_deciphered$fractions_coords) <= 7)) {
# store spep fractions
spe_fractions <- list(coords = spe_deciphered$fractions_coords,
names = spe_deciphered$fractions_names)
}
if (length(spe_deciphered$peaks_coords) > 0) {  # there are peaks
if ((length(spe_deciphered$peaks_coords) %% 2) == 0) {  # even number of coords
if (all(diff(spe_deciphered$peaks_coords) > 0)) {  # increasing positions
# store spep peaks
spe_peak_data <- spe_deciphered$peaks_coords
}
}
}
}
# extract short and long comments
short_comments <- std_comment(aaid_subset$comment_1)
long_comments <- std_comment(aaid_subset$comment_long)
# extract other important information
age <- uniquify_value(aaid_subset$age_sampling)
sex <- uniquify_value(aaid_subset$sex)
tp <- as.numeric(uniquify_value(aaid_subset$total_protein))
# store everything into a JSON
sample_json_data <- list(paid = aaid_subset$paid[1],
aaid = aaid_subset$aaid[1],
age = age,
sex = sex,
total_protein = tp,
short_comments = short_comments,
long_comments = long_comments,
traces=list(ELP = list(exists=T, data=elp_trace),
IgG = list(exists=T, data=g_trace),
IgA = list(exists=T, data=a_trace),
IgM = list(exists=T, data=m_trace),
K = list(exists=T, data=k_trace),
L = list(exists=T, data=l_trace),
Ref = list(exists=exactly_1_ref_trace_is_present, data=ref_trace),
SPE = list(exists=exactly_1_spe_trace_is_present, data=spe_trace, fractions=spe_fractions, peaks=spe_peak_data)))
# save at desired location
write(rjson::toJSON(sample_json_data, indent=2), file.path(input_json_directory, paste0(iter_aaid, ".json")))
# CHECK FOR A MATCH and if yes -> pre-fill in the output file (will be stored in a separate folder: previous_2020_output_jsons)
# in the past we used to "remove delimiters" while we are now replacing them with closest non-delimiter value
# so "old" traces should be 298-long while new will be 300 points in all cases
# thus, to "mimick" the old version of the trace, we just have to remove first and last values for ELP/GAMKL
# since there should not be any other delimiter
old_trace <- tail(head(elp_trace, 304-3), 304-6)
# get the trace hash
old_trace_md5 <- elp_trace_2_md5(old_trace)
# compare to list of known md5 (old traces)
if (old_trace_md5 %in% old_lemans_md5sum) {
old_dataset_position <- which(old_lemans_md5sum == old_trace_md5)
sample_output_json_data <- list(paid = aaid_subset$paid[1],
aaid = aaid_subset$aaid[1],
groundtruth_class=old_lemans_y_class[old_dataset_position],
groundtruth_maps=list(IgG = old_lemans_y_matrix[old_dataset_position, , 1],
IgA = old_lemans_y_matrix[old_dataset_position, , 2],
IgM = old_lemans_y_matrix[old_dataset_position, , 3],
K = old_lemans_y_matrix[old_dataset_position, , 4],
L = old_lemans_y_matrix[old_dataset_position, , 5]))
# save at desired location
write(rjson::toJSON(sample_output_json_data, indent=2), file.path(prefilled_output_json_directory, paste0(iter_aaid, ".json")))
}
} else {
skipped_list <- c(skipped_list, iter_aaid)
}
setTxtProgressBar(pb, iter_i)
}
exactly_1_spe_trace_is_present <- all(aaid_subset$n_spe == 1)
exactly_1_ref_trace_is_present <- all(aaid_subset$n_ref == 1)
at_least_1_short_comment <- any(nchar(aaid_subset$comment_1) >= 3)
at_least_1_long_comment <- any(nchar(aaid_subset$comment_long) >= 3)
# extract mandatory curves
elp_deciphered <- decipherCurve_v2024_2(aaid_subset[aaid_subset$analysis_sequence == "ELP", ])
g_deciphered <- decipherCurve_v2024_2(aaid_subset[aaid_subset$analysis_sequence == "IgG", ])
a_deciphered <- decipherCurve_v2024_2(aaid_subset[aaid_subset$analysis_sequence == "IgA", ])
m_deciphered <- decipherCurve_v2024_2(aaid_subset[aaid_subset$analysis_sequence == "IgM", ])
k_deciphered <- decipherCurve_v2024_2(aaid_subset[aaid_subset$analysis_sequence == "K", ])
l_deciphered <- decipherCurve_v2024_2(aaid_subset[aaid_subset$analysis_sequence == "L", ])
# extract accessory traces
ref_deciphered <- NULL
if (exactly_1_ref_trace_is_present) {
if (nchar(aaid_subset[aaid_subset$analysis_sequence == "Ref", ]$raw_curve) == 1200) {  # check the trace seems legit
ref_deciphered <- decipherCurve_v2024_2(aaid_subset[aaid_subset$analysis_sequence == "Ref", ])
} else {
exactly_1_ref_trace_is_present <- F
}
}
spe_deciphered <- NULL
if (exactly_1_spe_trace_is_present) {
if (nchar(aaid_subset[aaid_subset$program == "J", ]$raw_curve) == 1200) {  # check the trace seems legit
spe_deciphered <- decipherCurve_v2024_2(aaid_subset[aaid_subset$program == "J", ])
} else {
exactly_1_spe_trace_is_present <- F
}
}
# post-process traces
elp_trace <- postprocess_trace(elp_deciphered)
g_trace <- postprocess_trace(g_deciphered)
a_trace <- postprocess_trace(a_deciphered)
m_trace <- postprocess_trace(m_deciphered)
k_trace <- postprocess_trace(k_deciphered)
l_trace <- postprocess_trace(l_deciphered)
if (exactly_1_ref_trace_is_present) {
ref_trace <- postprocess_trace(ref_deciphered)
} else {
ref_trace <- NULL
}
spe_trace <- NULL
spe_fractions <- NULL
spe_peak_data <- NULL
if (exactly_1_spe_trace_is_present) {
# spe_trace <- postprocess_trace(spe_deciphered)
# store spep trace
spe_trace <- spe_deciphered$curve / max(spe_deciphered$curve)
if ((length(spe_deciphered$fractions_coords) >= 5) & (length(spe_deciphered$fractions_coords) <= 7)) {
# store spep fractions
spe_fractions <- list(coords = spe_deciphered$fractions_coords,
names = spe_deciphered$fractions_names)
}
if (length(spe_deciphered$peaks_coords) > 0) {  # there are peaks
if ((length(spe_deciphered$peaks_coords) %% 2) == 0) {  # even number of coords
if (all(diff(spe_deciphered$peaks_coords) > 0)) {  # increasing positions
# store spep peaks
spe_peak_data <- spe_deciphered$peaks_coords
}
}
}
}
# extract short and long comments
short_comments <- std_comment(aaid_subset$comment_1)
long_comments <- std_comment(aaid_subset$comment_long)
short_comments
long_comments
nchar(short_comments)
nchar(long_comments)
aaid_subset$paid
aaid_subset$paid[1]
# stop("Found some stuff")
iter_paid <- aaid_subset$paid[1]
# stop("Found some stuff")
iter_paid <- aaid_subset$paid[1]
paid_subset <- db_data[db_data$paid == iter_paid && !(db_data$aaid == iter_aaid), ]
db_data$paid
iter_paid
db_data$paid == iter_paid
paid_subset <- db_data[db_data$paid == iter_paid & !(db_data$aaid == iter_aaid), ]
paid_subset
nrow(paid_subset)
unique_aaids <- unique(db_data$aaid)
pb = txtProgressBar(min = 0, max = length(unique_aaids), initial = 0)
skipped_list = c()
for (iter_i in 1:length(unique_aaids)) {
iter_aaid = unique_aaids[iter_i]
aaid_subset <- db_data[db_data$aaid == iter_aaid, ]
# 1) CHECK IF EXACTLY 1 ELP, G, A, M, K, L
# EXTRACT G A M K L ELP TRACES
# EXTRACT IF PRESENT REF AND SPEP traces - skip if not present
# DECIPHER CURVES
# EXTRACT TEXT COMMENTS
# STORE EVERYTHING INTO A SINGLE JSON FILE
required_traces_are_present <- all(aaid_subset$n_elp == 1) &
all(aaid_subset$n_g == 1) &
all(aaid_subset$n_a == 1) &
all(aaid_subset$n_m == 1) &
all(aaid_subset$n_k == 1) &
all(aaid_subset$n_l == 1)
# also do other checks
required_traces_are_consistent <- ((nchar(aaid_subset[aaid_subset$analysis_sequence == "ELP", ]$raw_curve) == 1200) &
(nchar(aaid_subset[aaid_subset$analysis_sequence == "IgG", ]$raw_curve) == 1200) &
(nchar(aaid_subset[aaid_subset$analysis_sequence == "IgA", ]$raw_curve) == 1200) &
(nchar(aaid_subset[aaid_subset$analysis_sequence == "IgM", ]$raw_curve) == 1200) &
(nchar(aaid_subset[aaid_subset$analysis_sequence == "K", ]$raw_curve) == 1200) &
(nchar(aaid_subset[aaid_subset$analysis_sequence == "L", ]$raw_curve) == 1200))
if (required_traces_are_present & required_traces_are_consistent) {
exactly_1_spe_trace_is_present <- all(aaid_subset$n_spe == 1)
exactly_1_ref_trace_is_present <- all(aaid_subset$n_ref == 1)
at_least_1_short_comment <- any(nchar(aaid_subset$comment_1) >= 3)
at_least_1_long_comment <- any(nchar(aaid_subset$comment_long) >= 3)
# extract mandatory curves
elp_deciphered <- decipherCurve_v2024_2(aaid_subset[aaid_subset$analysis_sequence == "ELP", ])
g_deciphered <- decipherCurve_v2024_2(aaid_subset[aaid_subset$analysis_sequence == "IgG", ])
a_deciphered <- decipherCurve_v2024_2(aaid_subset[aaid_subset$analysis_sequence == "IgA", ])
m_deciphered <- decipherCurve_v2024_2(aaid_subset[aaid_subset$analysis_sequence == "IgM", ])
k_deciphered <- decipherCurve_v2024_2(aaid_subset[aaid_subset$analysis_sequence == "K", ])
l_deciphered <- decipherCurve_v2024_2(aaid_subset[aaid_subset$analysis_sequence == "L", ])
# extract accessory traces
ref_deciphered <- NULL
if (exactly_1_ref_trace_is_present) {
if (nchar(aaid_subset[aaid_subset$analysis_sequence == "Ref", ]$raw_curve) == 1200) {  # check the trace seems legit
ref_deciphered <- decipherCurve_v2024_2(aaid_subset[aaid_subset$analysis_sequence == "Ref", ])
} else {
exactly_1_ref_trace_is_present <- F
}
}
spe_deciphered <- NULL
if (exactly_1_spe_trace_is_present) {
if (nchar(aaid_subset[aaid_subset$program == "J", ]$raw_curve) == 1200) {  # check the trace seems legit
spe_deciphered <- decipherCurve_v2024_2(aaid_subset[aaid_subset$program == "J", ])
} else {
exactly_1_spe_trace_is_present <- F
}
}
# post-process traces
elp_trace <- postprocess_trace(elp_deciphered)
g_trace <- postprocess_trace(g_deciphered)
a_trace <- postprocess_trace(a_deciphered)
m_trace <- postprocess_trace(m_deciphered)
k_trace <- postprocess_trace(k_deciphered)
l_trace <- postprocess_trace(l_deciphered)
if (exactly_1_ref_trace_is_present) {
ref_trace <- postprocess_trace(ref_deciphered)
} else {
ref_trace <- NULL
}
spe_trace <- NULL
spe_fractions <- NULL
spe_peak_data <- NULL
if (exactly_1_spe_trace_is_present) {
# spe_trace <- postprocess_trace(spe_deciphered)
# store spep trace
spe_trace <- spe_deciphered$curve / max(spe_deciphered$curve)
if ((length(spe_deciphered$fractions_coords) >= 5) & (length(spe_deciphered$fractions_coords) <= 7)) {
# store spep fractions
spe_fractions <- list(coords = spe_deciphered$fractions_coords,
names = spe_deciphered$fractions_names)
}
if (length(spe_deciphered$peaks_coords) > 0) {  # there are peaks
if ((length(spe_deciphered$peaks_coords) %% 2) == 0) {  # even number of coords
if (all(diff(spe_deciphered$peaks_coords) > 0)) {  # increasing positions
# store spep peaks
spe_peak_data <- spe_deciphered$peaks_coords
}
}
}
}
# extract short and long comments
short_comments <- std_comment(aaid_subset$comment_1)
long_comments <- std_comment(aaid_subset$comment_long)
# stop("Found some stuff")
iter_paid <- aaid_subset$paid[1]
paid_subset <- db_data[db_data$paid == iter_paid & !(db_data$aaid == iter_aaid), ]
if (nrow(paid_subset) > 0) {
stop("Found interesting stuff")
short_comments <- std_comment(paid_subset$comment_1)
long_comments <- std_comment(paid_subset$comment_long)
} else {
next
}
# extract other important information
age <- uniquify_value(aaid_subset$age_sampling)
sex <- uniquify_value(aaid_subset$sex)
tp <- as.numeric(uniquify_value(aaid_subset$total_protein))
# store everything into a JSON
sample_json_data <- list(paid = aaid_subset$paid[1],
aaid = aaid_subset$aaid[1],
age = age,
sex = sex,
total_protein = tp,
short_comments = short_comments,
long_comments = long_comments,
traces=list(ELP = list(exists=T, data=elp_trace),
IgG = list(exists=T, data=g_trace),
IgA = list(exists=T, data=a_trace),
IgM = list(exists=T, data=m_trace),
K = list(exists=T, data=k_trace),
L = list(exists=T, data=l_trace),
Ref = list(exists=exactly_1_ref_trace_is_present, data=ref_trace),
SPE = list(exists=exactly_1_spe_trace_is_present, data=spe_trace, fractions=spe_fractions, peaks=spe_peak_data)))
# save at desired location
write(rjson::toJSON(sample_json_data, indent=2), file.path(input_json_directory, paste0(iter_aaid, ".json")))
# CHECK FOR A MATCH and if yes -> pre-fill in the output file (will be stored in a separate folder: previous_2020_output_jsons)
# in the past we used to "remove delimiters" while we are now replacing them with closest non-delimiter value
# so "old" traces should be 298-long while new will be 300 points in all cases
# thus, to "mimick" the old version of the trace, we just have to remove first and last values for ELP/GAMKL
# since there should not be any other delimiter
old_trace <- tail(head(elp_trace, 304-3), 304-6)
# get the trace hash
old_trace_md5 <- elp_trace_2_md5(old_trace)
# compare to list of known md5 (old traces)
if (old_trace_md5 %in% old_lemans_md5sum) {
old_dataset_position <- which(old_lemans_md5sum == old_trace_md5)
sample_output_json_data <- list(paid = aaid_subset$paid[1],
aaid = aaid_subset$aaid[1],
groundtruth_class=old_lemans_y_class[old_dataset_position],
groundtruth_maps=list(IgG = old_lemans_y_matrix[old_dataset_position, , 1],
IgA = old_lemans_y_matrix[old_dataset_position, , 2],
IgM = old_lemans_y_matrix[old_dataset_position, , 3],
K = old_lemans_y_matrix[old_dataset_position, , 4],
L = old_lemans_y_matrix[old_dataset_position, , 5]))
# save at desired location
write(rjson::toJSON(sample_output_json_data, indent=2), file.path(prefilled_output_json_directory, paste0(iter_aaid, ".json")))
}
} else {
skipped_list <- c(skipped_list, iter_aaid)
}
setTxtProgressBar(pb, iter_i)
}
paid_subset
short_comments <- std_comment(paid_subset$comment_1)
# extract short and long comments
short_comments <- std_comment(aaid_subset$comment_1)
long_comments <- std_comment(aaid_subset$comment_long)
short_comments
long_comments
other_short_comments
other_short_comments <- std_comment(paid_subset$comment_1)
other_long_comments <- std_comment(paid_subset$comment_long)
other_short_comments
other_long_comments
paid_subset$age_analysis
aaid_subset$age_analysis
aaid_subset$age_sampling
uniquify_value(aaid_subset$age_sampling)
unique_aaids <- unique(db_data$aaid)
pb = txtProgressBar(min = 0, max = length(unique_aaids), initial = 0)
skipped_list = c()
for (iter_i in 1:length(unique_aaids)) {
iter_aaid = unique_aaids[iter_i]
aaid_subset <- db_data[db_data$aaid == iter_aaid, ]
# 1) CHECK IF EXACTLY 1 ELP, G, A, M, K, L
# EXTRACT G A M K L ELP TRACES
# EXTRACT IF PRESENT REF AND SPEP traces - skip if not present
# DECIPHER CURVES
# EXTRACT TEXT COMMENTS
# STORE EVERYTHING INTO A SINGLE JSON FILE
required_traces_are_present <- all(aaid_subset$n_elp == 1) &
all(aaid_subset$n_g == 1) &
all(aaid_subset$n_a == 1) &
all(aaid_subset$n_m == 1) &
all(aaid_subset$n_k == 1) &
all(aaid_subset$n_l == 1)
# also do other checks
required_traces_are_consistent <- ((nchar(aaid_subset[aaid_subset$analysis_sequence == "ELP", ]$raw_curve) == 1200) &
(nchar(aaid_subset[aaid_subset$analysis_sequence == "IgG", ]$raw_curve) == 1200) &
(nchar(aaid_subset[aaid_subset$analysis_sequence == "IgA", ]$raw_curve) == 1200) &
(nchar(aaid_subset[aaid_subset$analysis_sequence == "IgM", ]$raw_curve) == 1200) &
(nchar(aaid_subset[aaid_subset$analysis_sequence == "K", ]$raw_curve) == 1200) &
(nchar(aaid_subset[aaid_subset$analysis_sequence == "L", ]$raw_curve) == 1200))
if (required_traces_are_present & required_traces_are_consistent) {
exactly_1_spe_trace_is_present <- all(aaid_subset$n_spe == 1)
exactly_1_ref_trace_is_present <- all(aaid_subset$n_ref == 1)
at_least_1_short_comment <- any(nchar(aaid_subset$comment_1) >= 3)
at_least_1_long_comment <- any(nchar(aaid_subset$comment_long) >= 3)
# extract mandatory curves
elp_deciphered <- decipherCurve_v2024_2(aaid_subset[aaid_subset$analysis_sequence == "ELP", ])
g_deciphered <- decipherCurve_v2024_2(aaid_subset[aaid_subset$analysis_sequence == "IgG", ])
a_deciphered <- decipherCurve_v2024_2(aaid_subset[aaid_subset$analysis_sequence == "IgA", ])
m_deciphered <- decipherCurve_v2024_2(aaid_subset[aaid_subset$analysis_sequence == "IgM", ])
k_deciphered <- decipherCurve_v2024_2(aaid_subset[aaid_subset$analysis_sequence == "K", ])
l_deciphered <- decipherCurve_v2024_2(aaid_subset[aaid_subset$analysis_sequence == "L", ])
# extract accessory traces
ref_deciphered <- NULL
if (exactly_1_ref_trace_is_present) {
if (nchar(aaid_subset[aaid_subset$analysis_sequence == "Ref", ]$raw_curve) == 1200) {  # check the trace seems legit
ref_deciphered <- decipherCurve_v2024_2(aaid_subset[aaid_subset$analysis_sequence == "Ref", ])
} else {
exactly_1_ref_trace_is_present <- F
}
}
spe_deciphered <- NULL
if (exactly_1_spe_trace_is_present) {
if (nchar(aaid_subset[aaid_subset$program == "J", ]$raw_curve) == 1200) {  # check the trace seems legit
spe_deciphered <- decipherCurve_v2024_2(aaid_subset[aaid_subset$program == "J", ])
} else {
exactly_1_spe_trace_is_present <- F
}
}
# post-process traces
elp_trace <- postprocess_trace(elp_deciphered)
g_trace <- postprocess_trace(g_deciphered)
a_trace <- postprocess_trace(a_deciphered)
m_trace <- postprocess_trace(m_deciphered)
k_trace <- postprocess_trace(k_deciphered)
l_trace <- postprocess_trace(l_deciphered)
if (exactly_1_ref_trace_is_present) {
ref_trace <- postprocess_trace(ref_deciphered)
} else {
ref_trace <- NULL
}
spe_trace <- NULL
spe_fractions <- NULL
spe_peak_data <- NULL
if (exactly_1_spe_trace_is_present) {
# spe_trace <- postprocess_trace(spe_deciphered)
# store spep trace
spe_trace <- spe_deciphered$curve / max(spe_deciphered$curve)
if ((length(spe_deciphered$fractions_coords) >= 5) & (length(spe_deciphered$fractions_coords) <= 7)) {
# store spep fractions
spe_fractions <- list(coords = spe_deciphered$fractions_coords,
names = spe_deciphered$fractions_names)
}
if (length(spe_deciphered$peaks_coords) > 0) {  # there are peaks
if ((length(spe_deciphered$peaks_coords) %% 2) == 0) {  # even number of coords
if (all(diff(spe_deciphered$peaks_coords) > 0)) {  # increasing positions
# store spep peaks
spe_peak_data <- spe_deciphered$peaks_coords
}
}
}
}
# extract short and long comments
short_comments <- std_comment(aaid_subset$comment_1)
long_comments <- std_comment(aaid_subset$comment_long)
# Find other comments for the same patients, if any
iter_paid <- aaid_subset$paid[1]
paid_subset <- db_data[db_data$paid == iter_paid & !(db_data$aaid == iter_aaid), ]
if (nrow(paid_subset) > 0) {
other_short_comments <- std_comment(paid_subset$comment_1)
other_long_comments <- std_comment(paid_subset$comment_long)
} else {
other_short_comments <- NULL
other_long_comments <- NULL
}
# extract other important information
age <- uniquify_value(aaid_subset$age_sampling)
sex <- uniquify_value(aaid_subset$sex)
tp <- as.numeric(uniquify_value(aaid_subset$total_protein))
# store everything into a JSON
sample_json_data <- list(paid = aaid_subset$paid[1],
aaid = aaid_subset$aaid[1],
age = age,
sex = sex,
total_protein = tp,
short_comments = short_comments,
long_comments = long_comments,
patient_other_short_comments = other_short_comments,
patient_other_long_comments = other_long_comments,
traces=list(ELP = list(exists=T, data=elp_trace),
IgG = list(exists=T, data=g_trace),
IgA = list(exists=T, data=a_trace),
IgM = list(exists=T, data=m_trace),
K = list(exists=T, data=k_trace),
L = list(exists=T, data=l_trace),
Ref = list(exists=exactly_1_ref_trace_is_present, data=ref_trace),
SPE = list(exists=exactly_1_spe_trace_is_present, data=spe_trace, fractions=spe_fractions, peaks=spe_peak_data)))
# save at desired location
write(rjson::toJSON(sample_json_data, indent=2), file.path(input_json_directory, paste0(iter_aaid, ".json")))
# CHECK FOR A MATCH and if yes -> pre-fill in the output file (will be stored in a separate folder: previous_2020_output_jsons)
# in the past we used to "remove delimiters" while we are now replacing them with closest non-delimiter value
# so "old" traces should be 298-long while new will be 300 points in all cases
# thus, to "mimick" the old version of the trace, we just have to remove first and last values for ELP/GAMKL
# since there should not be any other delimiter
old_trace <- tail(head(elp_trace, 304-3), 304-6)
# get the trace hash
old_trace_md5 <- elp_trace_2_md5(old_trace)
# compare to list of known md5 (old traces)
if (old_trace_md5 %in% old_lemans_md5sum) {
old_dataset_position <- which(old_lemans_md5sum == old_trace_md5)
sample_output_json_data <- list(paid = aaid_subset$paid[1],
aaid = aaid_subset$aaid[1],
groundtruth_class=old_lemans_y_class[old_dataset_position],
groundtruth_maps=list(IgG = old_lemans_y_matrix[old_dataset_position, , 1],
IgA = old_lemans_y_matrix[old_dataset_position, , 2],
IgM = old_lemans_y_matrix[old_dataset_position, , 3],
K = old_lemans_y_matrix[old_dataset_position, , 4],
L = old_lemans_y_matrix[old_dataset_position, , 5]))
# save at desired location
write(rjson::toJSON(sample_output_json_data, indent=2), file.path(prefilled_output_json_directory, paste0(iter_aaid, ".json")))
}
} else {
skipped_list <- c(skipped_list, iter_aaid)
}
setTxtProgressBar(pb, iter_i)
}
close(pb)
print(paste0("Skipped ", length(skipped_list), " samples due to missing data"))
skipped_list
